package balphabet;

import flixel.FlxG;
import funkin.graphics.FunkinSprite;

class BAlphabetCharacter extends FunkinSprite
{
    public var alignOffset:Float = 0;
    public var letterOffset:Array<Float> = [0, 0];

    public var row:Int = 0;
    public var rowWidth:Float = 0;

    public var doShake:Bool = false;
    public var isShakeOffset:Bool = false;
    public var shakeXOffset:Float = 0;
    public var shakeYOffset:Float = 0;
    public var doWave:Bool = false;
    public var waveOffset:Int = 0;

    public var bold:Bool = false;
    public var localScale:Float = 1;
    public var type:String = "unknown";
    public var typeface:String = "unknown";
    public var shouldUpdateFrames:Bool = false;
    public var monospace:Null<Bool> = null;

    public var character:Int = -1;
    public var plane:Int = 0;
    public var planeOffset:Int = 0;
    public var curLetter = null;

    public var spacesBefore:Int = 0;
    public var spacesTrailing:Int = 0;

    public var font:String = "default";
    public var fontData:BAFont = null;

    public function new(x, y)
    {
        super(x, y);
    }

    public function setupAlphaCharacter(x:Float, y:Float, characterCode:Int, isBold:Bool, newLocalScale:Float, parentScale:Array<Float>, _font:String):Void
    {
        this.x = x;
        this.y = y;
        
        localScale = newLocalScale;
        this.scale.x = parentScale[0] * localScale;
        this.scale.y = parentScale[1] * localScale;

        // Only fetch on the first setup or when the character changes.
        if (character != characterCode)
        {
            planeOffset = 0xFFFF * plane + plane;
            character = characterCode;
            character += planeOffset;
            curLetter = BAlphabetData.getLetter(character, _font);

            // Only set type on the first setup or when either typeface or font changes.
            if (type == "unknown" || typeface != curLetter.typeface || font != _font)
            {
                bold = isBold;
                type = bold ? "bold" : "regular";
                shouldUpdateFrames = true;
            }

            font = _font;
            typeface = curLetter.typeface;
            setTypeface(typeface);

            if (fontData.monospace)
            {
                monospace = true;
                // If set, letter monospace overrides font specific setting.
                if (curLetter.monospace != null) monospace = curLetter.monospace;
            }
            else
            {
                // DO NOT set a default value via ?? here.
                monospace = curLetter.monospace;
            }

            var alphaAnim:String = curLetter.anim + '-';
            animation.addByPrefix(alphaAnim, alphaAnim, 24, true);
            animation.play(alphaAnim, true);
        }

        // Special cases: the only change is boldness or font.
        if (font != _font)
        {
            font = _font;
            bold = isBold;
            type = bold ? "bold" : "regular";
            curLetter = BAlphabetData.getLetter(characterCode, font);
            typeface = curLetter.typeface;
            shouldUpdateFrames = true;
            setTypeface(typeface);

            var alphaAnim:String = curLetter.anim + '-';
            animation.addByPrefix(alphaAnim, alphaAnim, 24, true);
            animation.play(alphaAnim, true);
        }
        
        if (bold != isBold)
        {
            bold = isBold;
            type = bold ? "bold" : "regular";
            shouldUpdateFrames = true;
            setTypeface(typeface);

            var alphaAnim:String = curLetter.anim + '-';
            animation.addByPrefix(alphaAnim, alphaAnim, 24, true);
            animation.play(alphaAnim, true);
        }

        updateHitbox();
        updateLetterOffset();

        alignOffset = 0;
    }

    public function setTypeface(name:String):Void
    {
        if (frames == null || shouldUpdateFrames)
        {
            frames = Paths.getSparrowAtlas("balphabet/" + font + "/" + type + "/" + name);
            if (frames == null) // In case no bold version exists.
            {
                bold = false;
                type = "regular";
                frames = Paths.getSparrowAtlas("balphabet/" + font + "/regular/" + name);
            }
            if (frames == null) // Does that typeface not exist in the current font? FALLBACK TIME!!!
            {
                frames = Paths.getSparrowAtlas("balphabet/default/regular/" + name);
            }
            shouldUpdateFrames = false;
        }
    }

    public function setItalics():Void
    {
        this.skew.x = -20;
    }

    public function setColor(newColor:Int):Void
    {
        if (!curLetter.colored)
        {
            color = newColor;
        }
    }

    function updateLetterOffset():Void
    {
        if (animation.curAnim == null)
        {
            // trace(character);
            return;
        }

        var add:Float = bold ? fontData.heightBold : fontData.height;

        letterOffset[0] = curLetter.offsets[0];
        letterOffset[1] = curLetter.offsets[1];

        if (monospace ?? false)
        {
            var monowidth:Float = bold ? fontData.widthBold : fontData.width;
            if (monowidth == 0 && bold) monowidth = fontData.width;
            offset.x -= (monowidth / 2 - width / 2) * scale.x * localScale;
        }

        // Individual character x offsets can still apply even in monospace!
        // This is so characters don't have rely on invisible pixels to offset themselves.
        offset.x += letterOffset[0] * scale.x * localScale;

        if (scale.y < 0)
        {
            offset.y += (letterOffset[1] - (add / 2 * localScale)) * scale.y;
            flipX = true;
        }
        else
        {
            offset.y += (letterOffset[1] - (add / localScale - height)) * scale.y;
        }
    }

    function resetEffects():Void
    {
        this.alpha = 1;
        setColor(0xFFFFFFFF);
        this.skew.x = 0;
        doShake = false;
        isShakeOffset = false;
        shakeXOffset = 0;
        shakeYOffset = 0;
        doWave = false;
        waveOffset = 0;
    }

    var waveSine:Float = 0;
    var shakeTick:Float = 0;
    var shakeFramerate:Float = 16;
    var shakeSize:Float = 4;

    function update(elapsed:Float):Void
    {
        if (doShake)
        {
            shakeTick += elapsed;
            if (shakeTick >= 1 / shakeFramerate)
            {
                shakeTick %= 1 / shakeFramerate;
                if (!isShakeOffset)
                {
                    shakeXOffset = FlxG.random.float(-shakeSize * localScale, shakeSize * localScale);
                    shakeYOffset = FlxG.random.float(-shakeSize * localScale, shakeSize * localScale);
                    x += shakeXOffset;
                    y += shakeYOffset;
                    isShakeOffset = true;
                }
                else
                {
                    x -= shakeXOffset;
                    y -= shakeYOffset;
                    isShakeOffset = false;
                }
            }
        }

        if (doWave)
        {
            waveSine += elapsed;
            offset.y += (Math.sin((waveSine * 4) + (waveOffset * 0.5)) / 2) * scale.y;
        }
        
        super.update(elapsed);
    }
}