package balphabet;

import funkin.modding.module.Module;
import funkin.ui.mainmenu.MainMenuState;
import flixel.FlxG;
import haxe.Utf8;
import haxe.ds.IntMap;
import StringTools;

typedef BALetter = {
    anim:Null<String>,
    offsets:Array<Float>,
    colored:Null<Bool>,
    typeface:Null<String>
}

/**
 * This module contains the data relating to letters.
 * Letter sprites are stored in "images/balphabet/" and the data itself in "data/balphabet".
 * This system allows for unlimited letters, which can easily be added onto.
 * Now if you're asking, why such a powerful letter system? I hate vanilla Alphabet.hx
 * (It's been since replaced by AtlasText.hx which is better, I guess.)
 */
class BAlphabetData extends Module
{
    /**
     * Stores all loaded letter, big surprise...
     * Assigned in loadLetterData()
     * Letters are stored by their character code, instead of their represention as a string. (E.g. 65 instead of "A")
     */
    public static var allLetters:IntMap<Int, Null<BALetter>> = new IntMap();

    public static var uniqueTypefaces:Array<String> = [];

    public function new()
    {
        super('balphabet-data', 2);

        BAlphabetData.allLetters = new IntMap();
    }

    override public function onCreate(event:ScriptEvent):Void
    {
        loadLetterData();

        super.onCreate(event);
    }

    override public function onUpdate(event:ScriptEvent):Void
    {   
        if ((FlxG.state is MainMenuState) && FlxG.state.subState == null && FlxG.keys.pressed.SHIFT && FlxG.keys.justPressed.B)
        {
            FlxG.switchState(new BAlphabetTest());
        }

        super.onUpdate(event);
    }

    /**
     * Returns the letter at the given map index.
     * @param index 
     * @return BALetter
     */
    public static function getLetter(index:Int):BALetter
    {
        if (BAlphabetData.allLetters.exists(index))
        {
            return BAlphabetData.allLetters.get(index);
        }
        trace("No letter found for number: " + index + ". Returning fallback letter.");
        return {anim: "65533", offsets: [0, -8], colored: false, typeface: "specials"};
    }

    /**
     * Loads the letter data from the "data/balphabet" folder.
     * Ignores non-text files.
     */
    public function loadLetterData():Void
    {
        BAlphabetData.allLetters.clear();

        var alphabetList:Array<String> = Assets.list("TEXT").filter(function(file):Bool {
            return StringTools.contains(file, "data/balphabet/");
        });

        for (file in alphabetList)
        {
            if (!StringTools.endsWith(file, ".txt")) continue;
            file = file.substring(file.indexOf("/") + 1);
            var fullFile:String = Assets.getText(file);
            fullFile = StringTools.trim(fullFile);

            var typeface:String = file.substring(file.lastIndexOf("/") + 1, file.indexOf("."));
            if (!BAlphabetData.uniqueTypefaces.contains(typeface))
            {
                BAlphabetData.uniqueTypefaces.push(typeface);
            }
    
            var eachLine:Array<String> = fullFile.split("\n");
            for (character in eachLine)
            {
                var char:String = "";
                var offsets:Array<Float> = [0, 0];
                var colored:Bool = false;
    
                var elements:Array<String> = character.split(" ");
                for (element in elements)
                {
                    var elementInfo:Array<String> = element.split("=");
                    switch (elementInfo[0])
                    {
                        case "char":
                            char = StringTools.trim(elementInfo[1]);
                        case "offsetX":
                            offsets[0] = Std.parseFloat(elementInfo[1]);
                        case "offsetY":
                            offsets[1] = Std.parseFloat(elementInfo[1]);
                        case "colored":
                            colored = (elementInfo[1].toLowerCase() == "true" || elementInfo[1] == "1");
                        default:
                            trace("Invalid data!", character);
                    }
                }
                BAlphabetData.allLetters.set(Std.int(char), {anim: char, offsets: offsets, colored: colored, typeface: typeface});
            }
        }

        BAlphabetData.uniqueTypefaces.push("all");
    }

    // it works now????????????? wtf
    public static function fromCharCode(code:Int):String
    {
        var u = new Utf8();
        u.addChar(code);
        return u.toString();
    }
}