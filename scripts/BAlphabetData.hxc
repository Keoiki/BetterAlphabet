package balphabet;

import funkin.modding.module.Module;
import funkin.ui.mainmenu.MainMenuState;
import funkin.util.SerializerUtil;
import flixel.FlxG;
import haxe.Utf8;
import haxe.ds.IntMap;
import haxe.ds.StringMap;
using StringTools;

typedef BAFont = {
    height:Float,
    heightBold:Float,
    width:Float,
    widthBold:Float,
    monospace:Bool,
    padding:Float,
    paddingBold:Float,
    lineHeight:Float,
    spaceWidth:Float,
    letters:IntMap<Int, BALetter>
}

typedef BALetter = {
    anim:String,
    offsets:Array<Float>,
    monospace:Null<Bool>,
    colored:Bool,
    typeface:String
}

/**
 * This module contains the data relating to letters.
 * Letter sprites are stored in "images/balphabet/FONTNAME" and the data itself in "data/balphabet/FONTNAME".
 * This system allows for unlimited letters, which can easily be added onto.
 * (It's only unlimited if you're using `&#aaaa;` or `&#xaaaa;` for inputting the character. Otherwise the limit is `FFFF`)
 * Now if you're asking, why such a powerful letter system? I hate vanilla Alphabet.hx
 * (It's been since replaced by AtlasText.hx which is better, I guess.)
 */
class BAlphabetData extends Module
{
    /**
     * Stores all loaded fonts with their letter, big surprise...
     * Assigned in loadFontData()
     * Letters are stored by their character code, instead of their represention as a string. (E.g. 65 instead of "A")
     */
    public static var allFonts:StringMap<String, BAFont> = new StringMap();

    public static var uniqueTypefaces:Array<String> = [];
    public static var uniqueFonts:Array<String> = [];

    public function new()
    {
        super('balphabet-data', 2);

        BAlphabetData.allFonts = new StringMap();
    }

    override public function onCreate(event:ScriptEvent):Void
    {
        loadFontData();

        super.onCreate(event);
    }

    override public function onUpdate(event:ScriptEvent):Void
    {   
        if ((FlxG.state is MainMenuState) && FlxG.state.subState == null && FlxG.keys.pressed.SHIFT && FlxG.keys.justPressed.B)
        {
            FlxG.switchState(new BAlphabetTest());
        }

        super.onUpdate(event);
    }

    /**
     * Returns the letter at the given map index.
     * @param index Non-hex number of the letter
     * @param font Name of the font
     * @return BALetter
     */
    public static function getLetter(index:Int, font:String = "default"):BALetter
    {
        font ??= "default";
        if (BAlphabetData.allFonts.exists(font))
        {
            if (BAlphabetData.allFonts.get(font).letters.exists(index))
            {
                return BAlphabetData.allFonts.get(font).letters.get(index);
            }
        }
        trace("No letter found for number: " + index + " in font: " + font + ". Returning fallback letter.");
        return {anim: "65533", offsets: [0, -8], colored: false, typeface: "specials"};
    }

    /**
     * Loads the data for all fonts the mod can find.
     */
    function loadFontData():Void
    {
        BAlphabetData.allFonts.clear();

        var fontList:Array<String> = Assets.list("TEXT").filter(function(file):Bool {
            return file.contains("data/balphabet/") && file.endsWith(".json");
        });

        for (font in fontList)
        {
            font = font.substring(font.indexOf("/") + 1);
            var data:String = Assets.getText(font);
            data = SerializerUtil.fromJSON(data);
            var name:String = font.substring(font.lastIndexOf("/") + 1, font.indexOf("."));

            // Validate data, apply the "default" font's values if not set.
            data.height ??= 54;
            data.heightBold ??= 60;
            data.width ??= 54;
            data.widthBold ??= 54;
            data.monospace ??= false;
            data.padding ??= 2;
            data.paddingBold ??= -6;
            data.lineHeight ??= 85;
            data.spaceWidth ??= 28;

            data.letters = loadLetterData(name);
            BAlphabetData.allFonts.set(name, data);

            if (!BAlphabetData.uniqueFonts.contains(name))
            {
                BAlphabetData.uniqueFonts.push(name);
            }

            trace('Loaded font: $name');
        }

        BAlphabetData.uniqueTypefaces.push("all");
    }

    /**
     * Loads the letter data for the given font.
     */
    function loadLetterData(fontName:String):IntMap<Int, BALetter>
    {
        if (fontName == null)
        {
            return null;
        }

        var letters:IntMap<Int, BALetter> = new IntMap();

        var alphabetList:Array<String> = Assets.list("TEXT").filter(function(file):Bool {
            return file.contains("data/balphabet/" + fontName) && file.endsWith(".txt");
        });

        for (file in alphabetList)
        {
            file = file.substring(file.indexOf("/") + 1);
            var data:String = Assets.getText(file);
            data = data.trim();

            var typeface:String = file.substring(file.lastIndexOf("/") + 1, file.indexOf("."));
            if (!BAlphabetData.uniqueTypefaces.contains(typeface))
            {
                BAlphabetData.uniqueTypefaces.push(typeface);
            }
    
            var eachLine:Array<String> = data.split("\n");
            for (character in eachLine)
            {
                var char:String = "";
                var offsets:Array<Float> = [0, 0];
                var monospace:Null<Bool> = null;
                var colored:Bool = false;
    
                var elements:Array<String> = character.split(" ");
                for (element in elements)
                {
                    var elementInfo:Array<String> = element.split("=");
                    elementInfo[0] = elementInfo[0].trim();
                    elementInfo[1] = elementInfo[1].trim();
                    switch (elementInfo[0])
                    {
                        case "char":
                            char = elementInfo[1];
                        case "offsetX":
                            offsets[0] = Std.parseFloat(elementInfo[1]);
                        case "offsetY":
                            offsets[1] = Std.parseFloat(elementInfo[1]);
                        case "monospace":
                            monospace = (elementInfo[1].toLowerCase() == "true" || elementInfo[1] == "1");
                        case "colored":
                            colored = (elementInfo[1].toLowerCase() == "true" || elementInfo[1] == "1");
                        default:
                            trace("Invalid data!", character);
                    }
                }
                letters.set(Std.int(char), {anim: char, offsets: offsets, monospace: monospace, colored: colored, typeface: typeface});
            }
        }

        return letters;
    }

    // it works now????????????? wtf
    public static function fromCharCode(code:Int):String
    {
        var u = new Utf8();
        u.addChar(code);
        return u.toString();
    }
}