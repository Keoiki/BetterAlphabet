package balphabet;

import balphabet.BAlphabet;
import balphabet.BAlphabetTyped;
import funkin.util.tools.MapTools;
import funkin.ui.MusicBeatState;
import funkin.graphics.FunkinSprite;
import funkin.ui.mainmenu.MainMenuState;
import flixel.util.FlxSort;
import flixel.text.FlxText;
import StringTools;

import funkin.audio.FunkinSound;

class BAlphabetTest extends MusicBeatState
{
    var normalText:BAlphabet;
    var boldText:BAlphabet;
    var typedText:BAlphabetTyped;

    var textModule;
    var allLetterMap;
    var allLetterIndexes:Array<Int> = [];

    var offsetText;
    var offsetInfo:FlxText;
    var isOffsetBold:Bool = false;
    var letterIndex:Int = 0;
    var letterOffsets:Array<Float> = [0, 0];
    var modifiedOffsets:Array<Float> = [0, 0];
    var originalLetterOffsets:Array<Float> = [0, 0];

    var currentTypeface:Int = 0;
    var typefaceName:FlxText;
    var currentFont:Int = 0;
    var fontName:FlxText;
    var changedFont:Bool = false;

    public function new():Void
    {
        super();
    }

    public function create():Void
    {
        super.create();

        camera.bgColor = 0xFF7F7F7F;

        var sortOrder = function(a, b) {
            return FlxSort.byValues(-1, a, b);
        }

        allLetterMap = BAlphabetData.allFonts.get(BAlphabetData.uniqueFonts[currentFont]).letters;
        allLetterIndexes = MapTools.keyValues(allLetterMap);
        allLetterIndexes.sort(sortOrder);
        
        normalText = new BAlphabet(0, 0, "", BAlphabetData.uniqueFonts[currentFont]);
        add(normalText);
        
        boldText = new BAlphabet(normalText.width + 50, 0, "", BAlphabetData.uniqueFonts[currentFont]);
        add(boldText);

        typedText = new BAlphabetTyped(0, -500, "<b>Typed text testing,</b> <c=00FFAA>make sure</c> <i>this is</i> <s=0.5>a</s> <a=0.5>really</a> <W>long string</W> <S>to test it properly!</S>");
        add(typedText);
        typedText.letterCallback = () -> {
            FunkinSound.playOnce(Paths.sound("chartingSounds/keyboard" + FlxG.random.int(1, 3)), 1.5);  
        };
        typedText.finishCallback = () -> {
            FunkinSound.playOnce(Paths.sound("chartingSounds/metronome1"), 1.0);  
        };

        for (i in 0...3)
        {
            var alignmentLine = new FunkinSprite(0, -200 + (i * 25));
            alignmentLine.makeSolidColor(300, 4, 0x7F000000);
            add(alignmentLine);
        }

        offsetText = new BAlphabet(150, -200, "i!Aa", BAlphabetData.uniqueFonts[currentFont]);
        offsetText.setAlignment("center");
        add(offsetText);

        var test01:BAlphabet = new BAlphabet(0, -350, "<c=FF0000>HUNDREC</c>", "example");
        add(test01);
        var test02:BAlphabet = new BAlphabet(-10, -350, "<c=00FF00>ONEREC</c>", "example");
        test02.alignment = "right";
        add(test02);

        offsetInfo = new FlxText(0, -125, 0, "aaa", 16);
        add(offsetInfo);

        typefaceName = new FlxText(500, -125, 0, "aaa", 32);
        add(typefaceName);

        fontName = new FlxText(500, -175, 0, "aaa", 32);
        fontName.text = "Current font: " + BAlphabetData.uniqueFonts[currentFont];
        add(fontName);

        var unicodeTest = new BAlphabet(-100, 0, "&#65;&#x42;&#0067;&#x00044; &#x2190; ABCD?");
        unicodeTest.alignment = "right";
        add(unicodeTest);

        regenGlyphs(-1);
        changeOffsetCharacter(0);
    }

    public function update(elapsed:Float):Void
    {
        if (controls.BACK_P)
        {
            FlxG.switchState(new MainMenuState());
        }

        if (FlxG.keys.pressed.S) {
            camera.scroll.y += (FlxG.keys.pressed.SHIFT ? 10 : 5);
        }
        else if (FlxG.keys.pressed.W) {
            camera.scroll.y -= (FlxG.keys.pressed.SHIFT ? 10 : 5);
        }

        if (FlxG.keys.pressed.D) {
            camera.scroll.x += (FlxG.keys.pressed.SHIFT ? 10 : 5);
        }
        else if (FlxG.keys.pressed.A) {
            camera.scroll.x -= (FlxG.keys.pressed.SHIFT ? 10 : 5);
        }

        if (FlxG.keys.pressed.E) {
            camera.zoom += 0.01;
        }
        else if (FlxG.keys.pressed.Q) {
            camera.zoom -= 0.01;
        }

        if (FlxG.keys.justPressed.B)
        {
            isOffsetBold = !isOffsetBold;
            changeOffsetCharacter(0);
        }

        if (FlxG.keys.justPressed.T)
        {
            typedText.letterStep = FlxG.random.int(1, 10);
            typedText.resetText();
            typedText.startTyping();
        }

        if (FlxG.keys.justPressed.J)
        {
            regenGlyphs(-1);
        }
        else if (FlxG.keys.justPressed.K)
        {
            regenGlyphs(1);
        }

        if (FlxG.keys.justPressed.U)
        {
            currentFont = (currentFont + 1) % BAlphabetData.uniqueFonts.length;
            var sortOrder = function(a, b) {
                return FlxSort.byValues(-1, a, b);
            }
            allLetterMap = BAlphabetData.allFonts.get(BAlphabetData.uniqueFonts[currentFont]).letters;
            allLetterIndexes = MapTools.keyValues(allLetterMap);
            allLetterIndexes.sort(sortOrder);
            fontName.text = "Current font: " + BAlphabetData.uniqueFonts[currentFont];
            currentTypeface = BAlphabetData.uniqueTypefaces.indexOf("all");
            changedFont = true;
            regenGlyphs(0);
        }
        else if (FlxG.keys.justPressed.I)
        {
            currentFont = (currentFont + 1) % BAlphabetData.uniqueFonts.length;
            var sortOrder = function(a, b) {
                return FlxSort.byValues(-1, a, b);
            }
            allLetterMap = BAlphabetData.allFonts.get(BAlphabetData.uniqueFonts[currentFont]).letters;
            allLetterIndexes = MapTools.keyValues(allLetterMap);
            allLetterIndexes.sort(sortOrder);
            fontName.text = "Current font: " + BAlphabetData.uniqueFonts[currentFont];
            currentTypeface = BAlphabetData.uniqueTypefaces.indexOf("all");
            changedFont = true;
            regenGlyphs(0);
        }

        if (FlxG.keys.justPressed.Z) {
            changeOffsetCharacter((FlxG.keys.pressed.SHIFT ? -10 : -1) * (FlxG.keys.pressed.ALT ? 10 : 1));
        }
        else if (FlxG.keys.justPressed.C) {
            changeOffsetCharacter((FlxG.keys.pressed.SHIFT ? 10 : 1) * (FlxG.keys.pressed.ALT ? 10 : 1));
        }

        if (FlxG.keys.justPressed.RIGHT)
            changeOffsetOffset((FlxG.keys.pressed.SHIFT ? -10 : -1) / (FlxG.keys.pressed.ALT ? 10 : 1), 0);
        else if (FlxG.keys.justPressed.LEFT)
            changeOffsetOffset((FlxG.keys.pressed.SHIFT ? 10 : 1) / (FlxG.keys.pressed.ALT ? 10 : 1), 0);
        else if (FlxG.keys.justPressed.DOWN)
            changeOffsetOffset(0, (FlxG.keys.pressed.SHIFT ? -10 : -1) / (FlxG.keys.pressed.ALT ? 10 : 1));
        else if (FlxG.keys.justPressed.UP)
            changeOffsetOffset(0, (FlxG.keys.pressed.SHIFT ? 10 : 1) / (FlxG.keys.pressed.ALT ? 10 : 1));

        super.update(elapsed);
    }

    function regenGlyphs(change:Int = 0):Void
    {
        change ??= 0;

        currentTypeface = wrapAround(currentTypeface + change, 0, BAlphabetData.uniqueTypefaces.length - 1);
        var name:String = BAlphabetData.uniqueTypefaces[currentTypeface];

        var allGlyphs:String = "";
        for (i in 0...allLetterIndexes.length)
        {
            if (name != "all")
            {
                if (BAlphabetData.getLetter(allLetterIndexes[i]).typeface != name) continue;
            }
            allGlyphs += "&#" + allLetterIndexes[i] + ";";
            if (i % 30 == 0 && i != 0)
            {
                allGlyphs += "\n";
            }
        }

        if (changedFont)
        {
            normalText.font = BAlphabetData.uniqueFonts[currentFont];
            boldText.font = BAlphabetData.uniqueFonts[currentFont];
            offsetText.font = BAlphabetData.uniqueFonts[currentFont];
            changedFont = false;
        }

        typefaceName.text = "Current typeface: " + name;
        normalText.text = allGlyphs;
        boldText.text = "<b>" + allGlyphs + "</b>";
        boldText.x = normalText.width + 50;
    }

    public function changeOffsetCharacter(change:Int = 0):Void
    {
        letterIndex = wrapAround(letterIndex + change, 0, allLetterIndexes.length - 1);
        if (isOffsetBold)
        {
            offsetText.text = "<b>i&#" + allLetterIndexes[letterIndex] + ";IAa</b>";
        }
        else
        {
            offsetText.text = "i&#" + allLetterIndexes[letterIndex] + ";IAa";
        }
        var offsettedLetter = offsetText.letters[1];
        originalLetterOffsets[0] = offsettedLetter.offset.x;
        originalLetterOffsets[1] = offsettedLetter.offset.y;
        modifiedOffsets = [0, 0];
        letterOffsets = allLetterMap.get(allLetterIndexes[letterIndex]).offsets;
        updateOffsetInfo();
    }

    public function changeOffsetOffset(changeX:Int = 0, changeY:Int = 0):Void
    {
        modifiedOffsets[0] += changeX;
        modifiedOffsets[1] += changeY;
        var offsettedLetter = offsetText.letters[1];
        offsettedLetter.offset.set(originalLetterOffsets[0] + modifiedOffsets[0], originalLetterOffsets[1] + modifiedOffsets[1]);
        updateOffsetInfo();
    }

    public function updateOffsetInfo():Void
    {
        offsetInfo.text = "Glyph offset for glyph #" + allLetterIndexes[letterIndex] + " (" + StringTools.hex(allLetterIndexes[letterIndex], 4) + "):\n";
        offsetInfo.text += "x: " + (letterOffsets[0] + modifiedOffsets[0]) + " (" + originalLetterOffsets[0] + ")\n";
        offsetInfo.text += "y: " + (letterOffsets[1] + modifiedOffsets[1]) + " (" + originalLetterOffsets[1] + ")\n";
        offsetInfo.text += "index: " + letterIndex;
    }

    public function wrapAround(target:Int, min:Int, max:Int):Int
    {
        if (target < min) {
            return max;
        } else if (target > max) {
            return min;
        } else {
            return target;
        }
    }
}